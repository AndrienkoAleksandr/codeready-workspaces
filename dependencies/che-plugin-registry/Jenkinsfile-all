#!/usr/bin/env groovy

// build params
//BranchToBuildCRW - branch for crw plugin registry

timeout(120) {
    node {
        cleanWs()
        stage 'build extensions'

        // key value map for build jobs, where key is extension location in the registry
        def jobs = [:]

        checkout([$class: 'GitSCM',
            branches: [[name: "${branchToBuildCRW}"]],
            doGenerateSubmoduleConfigurations: false,
            poll: true,
            extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: "crw"]],
            submoduleCfg: [],
            userRemoteConfigs: [[url: "https://github.com/redhat-developer/codeready-workspaces.git"]]])

        def extensionFiles = findFiles(glob: 'crw/dependencies/che-plugin-registry/v3/plugins/**/meta.yaml')

        extensionFiles.each { extensionFile ->
            def extensionYaml = readYaml file: extensionFile.getPath()
            if (extensionYaml.type!="VS Code extension") {
                echo "not a VS Code extension: ${extensionFile.getPath()}"
                return
            }
            def extensionPaths = extensionYaml.spec.extensions
            if (!extensionPaths) {
                echo "extensions are not present in plugin ${extensionFile.getPath()} skipping"
                return
            }
            extensionPaths.each { extensionPath ->
                echo "processing extension ${extensionPath}"

                def registryLocation = extensionPath.split("//")[1]
                echo "selected extension ${registryLocation}"

                // since there may be multiple plugins pointing to the same extension URL
                // we just need to buld them once
                if (jobs.containsKey(registryLocation)) {
                    echo "duplicated plugin ${registryLocation} omitted"
                    return
                }

                def repository
                def branch

                if (registryLocation.contains("marketplace.visualstudio.com")) {
                    repository = extensionYaml.repository
                    // parse extension URL to get the version of the plugin, which should be second to last
                    def extensionName = extensionYaml.name

                    // infering the branch from the version of the plugin in the extension URL
                    // and prefixing with 'v'
                    branch = "v" + extensionPath.split("${extensionName}/")[1].split("/vspackage")[0]
                } else if (registryLocation.contains("download.jboss.org") || registryLocation.contains("github.com/che-incubator/")) {
                    // do not need to rebuild extensions hosted on jboss or che-incubator repositories
                    echo "omitting extension ${extensionPath}"
                    return
                } else if (registryLocation.contains("github.com")) {
                    repository = extensionPath.split("/releases/")[0];
                    // branch is infered from release tag
                    branch = registryLocation.split("/releases/download/")[1].split("/")[0];
                } else {
                    echo "omitting extension ${extensionPath}"
                    return
                }
                echo "processing extension ${extensionPath}"

                if ((repository) && (branch)) {

                    echo "adding a build job with repository ${repository} and branch ${branch}"
                    def buildjob = build job: 'vscode-extensions-packaging', parameters: [ string(name: 'extensionPath', value: repository), string(name: 'branchToBuildPlugin', value: branch) ]
                    jobs.put(registryLocation, buildjob)
                }

            }

        }
        sh "mkdir vsix"
        jobs.each { fileLocation, job ->
            echo "archiving artifact at ${fileLocation}"
            copyArtifacts(projectName: 'vscode-extensions-packaging', selector: specific("${job.number}"), target: "vsix/" + fileLocation)
        }

        sh "tar -czvf vsix.tar.gz vsix"

        archiveArtifacts artifacts: '*.tar.gz', fingerprint: true
    }
}
